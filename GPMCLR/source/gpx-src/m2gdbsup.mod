(****************************************************************)
(*								*)
(*		Modula-2 Compiler Source Module			*)
(*								*)
(*		  Parser and Tree Constructor.			*)
(*								*)
(* (c) copyright 1994 QUT Faculty of Information Technology 	*)
(*								*)
(*	original module : kjg November 1994			*)
(*	modifications   :					*)
(*								*)
(****************************************************************
$Log: m2gdbsup.mod,v $
Revision 1.16  1997/01/16 03:48:18  gough
changes to accomadate use of name and linkName fields (rather than origName)

Revision 1.15  1996/07/29 23:57:40  gough
prelimiary support for debugging strings.  Only descriptor block fields
are known with the pointer to the dynamic array being c_vstar type.

Revision 1.14  1996/03/21 02:08:53  lederman
change type of hiddens, opaqueTemp from 6 (C_ptr) to *5
for some reason type 6 doesn't work properly on RS6000

Revision 1.13  1996/01/10 06:30:21  lederman
more fiddling about for RS/6000 version

Revision 1.12  1995/10/10 23:22:49  lederman
gdbStabX support added for RS/6000

# Revision 1.11  1995/05/02  01:57:20  lederman
# Stop type recursion for arrays of anonymous element types => void
# these are generated by some forms of CAST to arrays requiring temporaries
#
# Revision 1.10  1995/02/23  03:54:40  lederman
# extensively modified to make it work on Alpha
# EmitTypeDef now attempts to unravel types before emmission
# New subrange types Int32 & Card32 added as implicit types
# Alpha gdb doesn't seem to understand name unmunging like other versions
# so special Alpha code is predicated with (bytesInWord = 8)
#
# Revision 1.9  1994/12/01  00:26:18  lederman
# fix problems with big sets and procvars in InlineTypes
#
# Revision 1.8  1994/11/29  02:22:01  gough
# improve handling of subranges in gdb stab output
#
# Revision 1.7  1994/11/21  07:46:44  gough
# make sure that BOOLEAN is treated as an enum, so that big-endian fetch works
#
# Revision 1.6  1994/11/20  22:34:14  gough
# for modules we emit callSmbl not id^.name !!!
#
# Revision 1.4  1994/11/19  05:12:41  gough
# make sure format pragma format is ... <cookie> _<name> ...
#
# Revision 1.3  1994/11/19  01:27:02  gough
# emit magicCookie == "%" to allow backend to decide about underscore
#
# Revision 1.2  1994/11/19  01:19:31  gough
# emit enumeration defs as union{val,ord}
#
# Revision 1.1  1994/11/15  04:41:45  gough
# Initial revision
*****************************************************************)


IMPLEMENTATION MODULE M2GdbSupport;
  IMPORT StdError, M2InOut, M2NodeDefs, M2NamGenerate;

  FROM SYSTEM IMPORT CAST;
  FROM M2Alphabets IMPORT HashBucketType;
  FROM M2NameHandler IMPORT GetSourceRep, anonBkt;
  FROM M2SSUtilities IMPORT MinOfOrdType, MaxOfOrdType, IsSignedType;
  FROM M2NodeDefs IMPORT IdNodeClass, TyNodeClass, FormalClass;
  FROM M2MachineConstants IMPORT bytesInWord, gdbXCOFF; 
  FROM GenSequenceSupport IMPORT 
	InitCursor, InitSequence, Sequence, ElemPtr, LinkRight, LinkLeft,
	IsEmpty, GetNext, Ended, DisposeList, Sequence;

  CONST bitsInByte = 8;
	maxDepth   = 2;
        magicCookie = "%";	(* ==> optional underscore *)
	maxLineLength = 1000;

  TYPE  StringType = ARRAY [0 .. 127] OF CHAR;

  VAR   nextTyNum  : CARDINAL;
	length     : CARDINAL;
	deferLst   : Sequence;

  PROCEDURE WByt(byt : CHAR);
  BEGIN
    INC(length);
    M2InOut.WriteObjByte(byt);
    IF byt = 12C THEN length := 0 END;
  END WByt;

  PROCEDURE WNam(n : HashBucketType);
      VAR ix,jx : CARDINAL;
          st : StringType;
  BEGIN
    ix := 0;
    GetSourceRep(n,st,ix);
    IF st[0] = "$" THEN st[0] := "_" END;
    FOR jx := 0 TO ix - 1 DO
      WByt(st[jx]);
    END;
  END WNam;
      
  PROCEDURE WStr(s : ARRAY OF CHAR);
      VAR ix : CARDINAL;
          ch : CHAR;
  BEGIN
    FOR ix := 0 TO HIGH(s) DO
      ch := s[ix];
      IF ch = "" THEN RETURN END;
      WByt(ch);
    END;
  END WStr;

  PROCEDURE WCrd(c : CARDINAL);
      VAR str : StringType;
	  idx : [0 .. 31];
  BEGIN
    IF c = 0 THEN WByt('0'); RETURN END;
    idx := 0;
    REPEAT
      str[idx] := CHR(c MOD 10 + ORD('0'));
      c := c DIV 10;
      INC(idx);
    UNTIL c = 0;
    FOR idx := idx - 1 TO 0 BY -1 DO 
      WByt(str[idx]);
    END;
  END WCrd;

  PROCEDURE WInt(c : INTEGER);
  BEGIN
   (* !!! is this safe for c = minInt  ??? *)
   (* !!! only if range checks are off !!! *)
   (* $T- *) (* $R- *) (* $I- *)
      IF c < 0 THEN
	WByt("-");
	c := -c;
      END;
      WCrd(c);
   (* $I= *) (* $R= *) (* $T= *)
  END WInt;

  PROCEDURE Prolog;
  BEGIN
    IF gdbXCOFF THEN WStr(';! .stabx "') ELSE WStr(';! .stabs "') END;
  END Prolog;

  PROCEDURE Epilog;
  BEGIN
    IF gdbXCOFF THEN WStr('",0,129,0'+12C) ELSE WStr('",128,0,0,0'+12C) END;
  END Epilog;

  PROCEDURE TypeEpilog;
  BEGIN
    IF gdbXCOFF THEN WStr('",0,140,0'+12C) ELSE WStr('",128,0,0,0'+12C) END;
  END TypeEpilog;

  PROCEDURE Split;
  BEGIN
    WStr("\\"); Epilog; Prolog;
  END Split;

  PROCEDURE EmitInitialTypes;
  BEGIN
    IF gdbXCOFF THEN
      Prolog; WStr("INTEGER:t1=-1");  TypeEpilog;
      Prolog; WStr("CARDINAL:t3=-9"); TypeEpilog;
      Prolog; WStr("C_char:t2=-2");   TypeEpilog;
      Prolog; WStr("BOOLEAN:t4=u1val:20=eFALSE:0,TRUE:1,,0,8;ord:1,0,8;;");
      TypeEpilog;
      Prolog; WStr("C_void:t5=-11");  TypeEpilog;
      Prolog; WStr("C_ptr:t6=*-11");  TypeEpilog;
      Prolog; WStr("SHORTREAL:t7=-12"); TypeEpilog;
      Prolog; WStr("REAL:t8=-13");    TypeEpilog;
      Prolog; WStr("PROC:t9=*10=f5"); TypeEpilog;
      Prolog; WStr("CHAR:t11=-5");    TypeEpilog;
      Prolog; WStr("BYTE:t12=-5");    TypeEpilog;
      Prolog; WStr("WORD:t13");       TypeEpilog;
      Prolog; WStr("BITSET:t14=3");   TypeEpilog;
      Prolog; WStr("ADDRESS:t15=*5"); TypeEpilog;
      Prolog; WStr("Int16:t16=-3");   TypeEpilog;
      Prolog; WStr("Card16:t17=-7");  TypeEpilog;
      Prolog; WStr("Int8:t18=-2");    TypeEpilog;
      Prolog; WStr("Card8:t19=-5");   TypeEpilog;
      Prolog; WStr("Int32:t20=-1");   TypeEpilog;
      Prolog; WStr("Card32:t21=-9");  TypeEpilog;
    ELSE
      IF bytesInWord = 8 THEN  (* alpha *)
        Prolog; 
        WStr("INTEGER:t1=r1;001000000000000000000000;000777777777777777777777"); 
        TypeEpilog;
        Prolog; WStr("CARDINAL:t3=r1;0;001777777777777777777777"); TypeEpilog;
      ELSE
 (*     WStr(';! .stabs "__gpm_compiled.", 0x3c, 0, 0, 0' + 12C);     *)
        Prolog; WStr("INTEGER:t1=r1;0020000000000;0017777777777"); TypeEpilog;
        Prolog; WStr("CARDINAL:t3=r1;0;0037777777777"); TypeEpilog;
      END;
      Prolog; WStr("C_char:t2=r1;-128;127"); TypeEpilog;
      Prolog; WStr("BOOLEAN:t4=u1val:20=eFALSE:0,TRUE:1,,0,8;ord:1,0,8;;");
      TypeEpilog;
      Prolog; WStr("C_void:t5=5"); TypeEpilog;
      Prolog; WStr("C_ptr:t6=*5"); TypeEpilog;
      Prolog; WStr("SHORTREAL:t7=r1;4;0"); TypeEpilog;
      Prolog; WStr("REAL:t8=r1;8;0"); TypeEpilog;
      Prolog; WStr("PROC:t9=*10=f5"); TypeEpilog;
      Prolog; WStr("CHAR:t11=r1;0;255"); TypeEpilog;
      Prolog; WStr("BYTE:t12=r1;0;255"); TypeEpilog;
      Prolog; WStr("WORD:t13"); TypeEpilog;
      Prolog; WStr("BITSET:t14=3"); TypeEpilog;
      Prolog; WStr("ADDRESS:t15=*5"); TypeEpilog;
      Prolog; WStr("Int16:t16=r1;-32768;32767"); TypeEpilog;
      Prolog; WStr("Card16:t17=r1;0;65535"); TypeEpilog;
      Prolog; WStr("Int8:t18=r1;-128;127"); TypeEpilog;
      Prolog; WStr("Card8:t19=r1;0;255"); TypeEpilog;
      Prolog; WStr("Int32:t20=r1;0020000000000;0017777777777"); TypeEpilog;
      Prolog; WStr("Card32:t21=r1;0;0037777777777"); TypeEpilog;
    END;
  END EmitInitialTypes;

  PROCEDURE InlineType(type  : M2NodeDefs.TypeDesc;
		       depth : CARDINAL);

    PROCEDURE DoUnionFields(uCurs : ElemPtr);
      VAR fCurs : ElemPtr;
	  pCurs : ElemPtr;
	  iElem : M2NodeDefs.IdDesc;
	  vElem : M2NodeDefs.TypeDesc;
    BEGIN
     (*
      *  Here we sneakily flatten the namespace
      *  by going directly to the field names.
      *)
      WHILE NOT Ended(uCurs) DO
	GetNext(uCurs,vElem);
	InitCursor(vElem^.fieldSeq,fCurs);
	WHILE NOT Ended(fCurs) DO
 	  IF length > maxLineLength THEN Split END;
	  GetNext(fCurs,iElem);
	  IF iElem^.fieldType^.tyClass = unions THEN
	    InitCursor(iElem^.fieldType^.varSeq,pCurs);
	    DoUnionFields(pCurs);
	  ELSE
	    WNam(iElem^.name); WByt(":");
	    InlineType(iElem^.fieldType,1);
	    WByt(","); WCrd(iElem^.fieldOffset * bitsInByte);
	    WByt(","); WCrd(iElem^.fieldType^.size * bitsInByte); WByt(";");
	  END;
	END;
      END;
    END DoUnionFields;

    PROCEDURE EmitSubrangeOrd(type : M2NodeDefs.TypeDesc);
      TYPE SizeToNumMap = ARRAY [1 .. 8] OF CARDINAL;
      CONST mapI32 = SizeToNumMap{18,16,5, 1,5,5,5,5};
	    mapC32 = SizeToNumMap{19,17,5, 3,5,5,5,5};
	    mapI64 = SizeToNumMap{18,16,5,20,5,5,5,1};
	    mapC64 = SizeToNumMap{19,17,5,21,5,5,5,1};
    BEGIN
      IF (type^.hostType^.tyClass = enums) OR
         (type^.hostType^.tyClass = chars) THEN
        InlineType(type^.hostType,1);
      ELSIF IsSignedType(type) THEN
	IF bytesInWord = 8 THEN  (* alpha *)
	  WCrd(mapI64[type^.size]);
	ELSE
	  WCrd(mapI32[type^.size]);
	END;
      ELSE
	IF bytesInWord = 8 THEN  (* alpha *)
	  WCrd(mapC64[type^.size]);
	ELSE
	  WCrd(mapC32[type^.size]);
	END;
      END;
    END EmitSubrangeOrd;

    VAR iElem : M2NodeDefs.IdDesc;
	eCurs : ElemPtr;
	pCurs : ElemPtr;
	ix    : CARDINAL;
  BEGIN
    IF type^.dumped THEN WCrd(type^.tyNumber);
    ELSE
      IF type^.tyNumber = 0 THEN
        IF type^.tyName <> anonBkt THEN LinkRight(deferLst,type) END;
        type^.tyNumber := nextTyNum; INC(nextTyNum);
      END;
      IF type^.tyClass = subranges THEN
	EmitSubrangeOrd(type);
	RETURN;			(* Forward referenced subranges don't work *)
      ELSE
	WCrd(type^.tyNumber);
      END;
      IF (depth > 0) AND (type^.tyName <> anonBkt) THEN
	RETURN;			(* Don't expand named types inline *)
      END;
      WByt("="); 
      CASE type^.tyClass OF
      | sets : 
	  IF type^.size > bytesInWord THEN
	    WStr("ar1;0;"); WCrd(type^.size DIV bytesInWord - 1); WByt(";"); 
	  END;
	  WStr("14");
      | enums :
          WStr("u1val:"); WCrd(nextTyNum); INC(nextTyNum); WStr("=e");
         (*
          *  Enumerations are declared as
          *
          *     union { val : EnumType;
          *             ord : Card8;
          *     }
          *
          *  so that they are printed as {val = <conId>, ord = <conOrd> }
          *  and so that gdb is forced into taking just 8 bits.
          *)
	  InitCursor(type^.conSeq,eCurs);
	  FOR ix := 0 TO type^.cardinality - 1 DO
	    IF length > maxLineLength THEN Split END;
	    GetNext(eCurs,iElem);
	    WNam(iElem^.name); WByt(":"); WCrd(ix); WByt(",");
	  END;
          WStr(",0,8;ord:1,0,8;;");     (* ==> only 8 bits *)
      | arrays :
	  WStr("ar1;"); 
	  WInt(CAST(INTEGER,MinOfOrdType(type^.indexType))); WByt(";");
	  WInt(CAST(INTEGER,MaxOfOrdType(type^.indexType))); WByt(";"); 
	  IF type^.elementType = NIL THEN WStr("5"); (** $anon$ **)
	  ELSE
	    InlineType(type^.elementType,1);
	  END;
      | pointers :
	  WStr("*"); InlineType(type^.targetType,1);
      | hiddens, opaqueTemp :
	  WStr("*5"); 
      | stringTs :
	  WStr("*"); 
	  WCrd(nextTyNum); INC(nextTyNum);
	  WStr("=s12info:");
	  WCrd(nextTyNum); INC(nextTyNum);
	  WStr("=*5,0,32;high:1,32,32;limit:3,64,32;;");
      | records :
	  WByt("s");
	  WCrd(type^.size);
	  InitCursor(type^.fieldSeq,eCurs);
	  WHILE NOT Ended(eCurs) DO
 	    IF length > maxLineLength THEN Split END;
	    GetNext(eCurs,iElem);
	    IF iElem^.fieldType^.tyClass = unions THEN
	      InitCursor(iElem^.fieldType^.varSeq,pCurs);
	      DoUnionFields(pCurs);
	    ELSE
	      WNam(iElem^.name); WByt(":"); InlineType(iElem^.fieldType,1);
	      WByt(","); WCrd(iElem^.fieldOffset * bitsInByte);
	      WByt(","); WCrd(iElem^.fieldType^.size * bitsInByte); WByt(";");
	    END;
	  END;
	  WByt(";");
      | procTypes, funcTypes :
	  WByt("*");
	  WCrd(nextTyNum); INC(nextTyNum); 
	  WStr("=f");
	  IF type^.result = NIL THEN
	    WByt("5");
	  ELSE 
	    InlineType(type^.result,1);
	  END;
      END; (* case *)
    END;
  END InlineType;

  PROCEDURE EmitTypeDef(type : M2NodeDefs.TypeDesc);

    PROCEDURE FindNestedTypes(type : M2NodeDefs.TypeDesc; depth: CARDINAL);

      PROCEDURE DoUnionFields(uCurs : ElemPtr);
        VAR fCurs : ElemPtr;
	    pCurs : ElemPtr;
	    iElem : M2NodeDefs.IdDesc;
	    vElem : M2NodeDefs.TypeDesc;
      BEGIN
        WHILE NOT Ended(uCurs) DO
	  GetNext(uCurs,vElem);
	  InitCursor(vElem^.fieldSeq,fCurs);
	  WHILE NOT Ended(fCurs) DO
	    GetNext(fCurs,iElem);
	    IF iElem^.fieldType^.tyClass = unions THEN
	      InitCursor(iElem^.fieldType^.varSeq,pCurs);
	      DoUnionFields(pCurs);
	    ELSE
	      FindNestedTypes(iElem^.fieldType,depth+1);
	    END;
	  END;
        END;
      END DoUnionFields;

      VAR iElem : M2NodeDefs.IdDesc;
	  eCurs : ElemPtr;
	  pCurs : ElemPtr;
    BEGIN
      IF (type^.tyName <> anonBkt) AND NOT type^.dumped THEN
        IF type^.tyNumber = 0 THEN
	  LinkLeft(deferLst,type);
          type^.tyNumber := nextTyNum; INC(nextTyNum);
        END;
        CASE type^.tyClass OF
        | arrays :
	    FindNestedTypes(type^.elementType,depth+1);
        | pointers :
 	    IF depth < maxDepth THEN
	      FindNestedTypes(type^.targetType,depth+1);
	    END;
        | records :
	    InitCursor(type^.fieldSeq,eCurs);
	    WHILE NOT Ended(eCurs) DO
	      GetNext(eCurs,iElem);
	      IF iElem^.fieldType^.tyClass = unions THEN
	        InitCursor(iElem^.fieldType^.varSeq,pCurs);
	        DoUnionFields(pCurs);
	      ELSE
	        FindNestedTypes(iElem^.fieldType,depth+1);
	      END;
	    END;
        | procTypes, funcTypes :
	    IF type^.result <> NIL THEN
	      FindNestedTypes(type^.result,depth+1);
	    END;
        | subranges :
	    IF (type^.hostType^.tyClass = enums) OR
	       (type^.hostType^.tyClass = chars) THEN
	      FindNestedTypes(type^.hostType,depth+1);
	    END;
	ELSE  (* base type *)
	END;
      END;
    END FindNestedTypes;

    VAR elem : M2NodeDefs.IdDesc;
	curs : ElemPtr;
	ix   : CARDINAL;
  BEGIN
    IF (type^.tyName <> anonBkt) AND NOT type^.dumped THEN
      IF type^.tyNumber = 0 THEN
        type^.tyNumber := nextTyNum; INC(nextTyNum);
      END;
      FindNestedTypes(type,0);
      IF NOT IsEmpty(deferLst) THEN DumpSequence END;
      Prolog; 
      WNam(type^.tyName); WStr(":t");
      IF type^.tyClass = subranges THEN WCrd(type^.tyNumber); WByt("=") END;
      InlineType(type,0);
      TypeEpilog;
      type^.dumped := TRUE;
    END;
  END EmitTypeDef;


  PROCEDURE EmitLocal(type : M2NodeDefs.TypeDesc; isVar : BOOLEAN);
  BEGIN
    WStr('	"');
    IF isVar THEN 
      WCrd(nextTyNum); INC(nextTyNum); WStr("=*");
    END;
    InlineType(type,0);
    WByt('"');
  END EmitLocal;

  PROCEDURE EmitObject(id : M2NodeDefs.IdDesc);
  BEGIN
    IF id^.idClass = varNode THEN
      EmitTypeDef(id^.varType);
     (*
      *  Emit a stab for an unmunged name (pretending that
      *  this is a local symbol whether it is or not) _then_
      *  if the symbol is exported also emit a munged stab.
      *  **** Doesn't seem to work on alpha *****
      *)
(*****)
      IF (bytesInWord = 8) AND (id^.varClass <> export) THEN  (* alpha *)
        Prolog; WByt(magicCookie); WByt("_"); WNam(id^.linkName);
	WStr(":S"); InlineType(id^.varType,0); WStr('",40,0,0,'); 
	WByt(magicCookie); WByt("_"); WNam(id^.name); WByt(12C);
      ELSE
(*****)
        IF gdbXCOFF THEN WStr(';# .stabx "') ELSE WStr(';! .stabs "') END;
	WNam(id^.name); WStr(":S"); InlineType(id^.varType,0); WStr('",');
	IF gdbXCOFF THEN
	  WByt(magicCookie); WStr("__"); WNam(id^.linkName); 
	  IF id^.varClass = export THEN WStr('{RW}') END;
	  WStr(',133,0');
	ELSE
	  WStr('40,0,0,'); WByt(magicCookie); WByt("_"); WNam(id^.linkName);
	END;
	WByt(12C);
      END;
      IF id^.varClass = export THEN
        Prolog; WNam(id^.linkName); WStr(":G"); 
	InlineType(id^.varType,0); WStr('",');
	IF gdbXCOFF THEN
	  WByt("_"); WNam(id^.linkName); WStr('{RW},128,0');
	ELSE
	  WStr('32,0,0,0');
	END;
	WByt(12C);
      END;
    ELSIF (id^.idClass = procHeader) THEN
      IF id^.procType^.result <> NIL THEN EmitTypeDef(id^.procType^.result) END;
      IF gdbXCOFF THEN WStr(';# .stabx "') ELSE WStr(';! .stabs "') END;
      WNam(id^.name); WStr(":F");
      IF id^.procType^.result = NIL THEN
	WByt("5");
      ELSE 
	InlineType(id^.procType^.result,0);
      END;
      WStr('",');
      IF gdbXCOFF THEN 
        WByt(magicCookie); WStr("_."); WNam(id^.linkName); WStr(',142,0');
      ELSE
        WStr('36,0,'); WCrd(id^.body^.headerLine); WByt(",");
	WByt(magicCookie); WByt("_"); WNam(id^.linkName);
      END;
      WByt(12C);
(*****)
      IF bytesInWord = 8 THEN  (* alpha *)
        Prolog; WByt(magicCookie); WByt("_"); WNam(id^.linkName);
        WStr(':F5",36,0,'); WCrd(id^.body^.headerLine); WByt(",");
        WByt(magicCookie); WByt("_"); WNam(id^.linkName); WByt(12C);
      END;
(*****)
    ELSIF (id^.idClass = procNode) THEN
      IF id^.procType^.result <> NIL THEN EmitTypeDef(id^.procType^.result) END;
      IF gdbXCOFF THEN WStr(';# .stabx "') ELSE WStr(';! .stabs "') END;
      WNam(id^.linkName); WStr(":f");
      IF id^.procType^.result = NIL THEN
	WByt("5");
      ELSE 
	InlineType(id^.procType^.result,0);
      END;
      WStr('",');
      IF gdbXCOFF THEN
        WByt(magicCookie); WStr("_."); WNam(id^.linkName); WStr(',142,0');
      ELSE
        WStr('36,0,'); WCrd(id^.body^.headerLine); WByt(",");
	WByt(magicCookie); WByt("_"); WNam(id^.linkName);
      END;
      WByt(12C);
    ELSIF (id^.idClass = modNode) THEN
      IF gdbXCOFF THEN WStr(';# .stabx "') ELSE WStr(';! .stabs "') END;
      WNam(id^.name); WStr(':F5",');
      IF gdbXCOFF THEN
        WByt(magicCookie); WStr("_."); WNam(M2NamGenerate.callSmbl); WStr(',142,0');
      ELSE
        WStr('36,0,'); WCrd(id^.body^.headerLine); WByt(",");
        WByt(magicCookie); WByt("_"); WNam(M2NamGenerate.callSmbl);
      END;
      WByt(12C);
(*****)
      IF bytesInWord = 8 THEN  (* alpha *)
        Prolog; WByt(magicCookie); WByt("_"); WNam(M2NamGenerate.callSmbl);
        WStr(':F5",36,0,'); WCrd(id^.body^.headerLine); WByt(",");
        WByt(magicCookie); WByt("_"); WNam(M2NamGenerate.callSmbl); WByt(12C);
      END;
(*****)
    END;
    IF NOT IsEmpty(deferLst) THEN DumpSequence END;
  END EmitObject;

  PROCEDURE DumpSequence;
    VAR curs : ElemPtr;
	elem : M2NodeDefs.TypeDesc;
	list : Sequence;
  BEGIN
    list := deferLst;
    InitSequence(deferLst);
    InitCursor(list,curs);
    WHILE NOT Ended(curs) DO
      GetNext(curs,elem);
      EmitTypeDef(elem);
    END;
    DisposeList(list);
  END DumpSequence;

BEGIN
  length := 0;
  nextTyNum := 22;
  InitSequence(deferLst);
END M2GdbSupport.
